<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>D&D Inventory (Mobile)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<link rel="manifest" href="manifest.webmanifest">
<style>
/* ======== NO PAGE SCROLL + DRAG-SAFE BASE ======== */
body {
  margin: 0;
  font: 14px/1.35 'Crimson Text', 'Book Antiqua', 'Palatino Linotype', Georgia, serif;
  color: #e9e5dc;
  background: #0b0c0d;
}
body {
  margin: 0;
  font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, "Inter", Arial, sans-serif;
  color: #e9e5dc;
  background: #0b0c0d;
}

/* Pin app to viewport, disable touch panning (we handle long-press drag) */
.screen{
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100svh;           /* safe viewport height (mobile toolbars aware) */
  display: flex;
  flex-direction: column;
  padding: 12px;
  box-sizing: border-box;   /* include padding in width/height calculations */
  background: #151616 url("assets/Background.png") center/cover no-repeat;
  touch-action: none;       /* prevent native pan/zoom */
  -webkit-user-select: none;
  user-select: none;
}
/* ======== THEME VARS ======== */
:root{
  --spell-row-min-h: 44px;   /* compact row height (was bigger) */
  --spell-collapsed-h: 32px; /* slim header height when collapsed */
  --topbar-h: 30px;

/* Portrait (borderless) */
  --portrait-width: 68%;
  --portrait-height: 110px;
  --portrait-offset-x: 0px;

/* Clothing (left column) - 20% smaller */
  --wearables-gap: 3px;
  --wearable-width: 96px;
  --wearable-height: 13px;

  /* Weapons (under portrait) */
  --wep-gap: 3px;
  --wep-slot-h: 12px;
  --wep-slot-rad: 6px;

  /* Quiver split */
  --quiver-min-h: 24px;

/* Equipment (bottom) */
  --equip-cols: 2;
  --equip-gap: 4px;
  --equip-min-h: 70px;           /* reduced more aggressively */

/* Colors */
  --text: #e9e5dc;
  --muted: #beb8ab;
  --accent-gold: #d4af37;
  --accent-gold-dark: #b8941f;
  --slot-bg: rgba(0,0,0,0.55);
  --slot-border-color: #777;
  --slot-border: 2px solid var(--slot-border-color);

  /* Items */
  --item-font-size: 8px;

  /* Capacity bar */
  --cap-track: #2a2a2a;
  --cap-grad: linear-gradient(90deg, #2e7d32, #ff9800); /* green -> orange */
}

/* ======== TOP BAR ======== */
.topbar{
  height: var(--topbar-h);
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: 8px;
  z-index: 100; /* ensure topbar stays above other content */
  position: relative;
  margin-bottom: 8px;
}

.left-controls {
  display: flex;
  align-items: center;
  gap: 6px;
}

.right-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

.btn-plus{
  width: 32px; height: 32px; display: grid; place-items: center;
  font-size: 18px; line-height: 1; border-radius: 6px;
  background: var(--slot-bg); border: var(--slot-border); color: var(--text);
  cursor: pointer;
  touch-action: manipulation; /* Prevent double-tap zoom */
}
.coins{ display: flex; align-items: center; gap: 8px; }
.coin{
  display: flex; align-items: center; gap: 3px;
  padding: 2px 4px; border-radius: 999px; background: rgba(0,0,0,0.35);
  border: 1px solid #4a4337;
}

.icon{
  width: 12px; height: 12px; border-radius: 50%;
  box-shadow: inset 0 1px 0 #fff2, 0 1px 2px #0008;
  background-size: cover;
  background-position: center;
}

.gold  { 
  background: url('assets/Goldcoins.png') center/cover no-repeat;
  box-shadow: inset 0 1px 0 #fff3, 0 1px 2px #0008;
}
.silver{ 
  background: url('assets/Silvercoins.png') center/cover no-repeat;
  box-shadow: inset 0 1px 0 #fff3, 0 1px 2px #0008;
}
.copper{ 
  background: url('assets/Coppercoins.png') center/cover no-repeat;
  box-shadow: inset 0 1px 0 #fff3, 0 1px 2px #0008;
}
.coin input{
  width: 30px; height: 18px;
  background: #141414; color: var(--text);
  border: 1px solid #000; outline: 1px solid #43371e;
  border-radius: 4px; padding: 0 3px; font-size: 10px;
  touch-action: auto;
}

.survival-indicators {
  display: flex;
  gap: 8px;
  align-items: flex-start;
}

.survival-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1px;
}

.quick-btn {
  width: 16px;
  height: 12px;
  background: linear-gradient(#26231e, #1b1916);
  border: 1px solid #3c311c;
  border-radius: 3px;
  color: var(--text);
  font-size: 8px;
  cursor: pointer;
  touch-action: manipulation;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.quick-btn:hover {
  background: linear-gradient(#32281f, #221e19);
  transform: translateY(-1px);
}

.quick-btn:active {
  transform: translateY(0);
  background: linear-gradient(#1b1916, #26231e);
}

.indicator {
  position: relative;
  cursor: pointer;
}

.icon-container {
  position: relative;
  width: 24px;
  height: 24px;
  border-radius: 4px;
  overflow: hidden;
  background: var(--slot-bg);
  border: 1px solid var(--slot-border-color);
}

.survival-icon {
  width: 100%;
  height: 100%;
  object-fit: contain;
  filter: grayscale(1);
  transition: filter 0.3s ease;
}

.fill-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 0%;
  transition: height 0.5s ease;
  pointer-events: none;
}

.water-fill {
  background: linear-gradient(0deg, #1565c0 0%, #42a5f5 50%, #81d4fa 100%);
  opacity: 0.8;
}

.rations-fill {
  background: linear-gradient(0deg, #2e7d32 0%, #66bb6a 50%, #a5d6a7 100%);
  opacity: 0.7;
}

.indicator.has-resources .survival-icon {
  filter: grayscale(0);
}

.spellbook-icon {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  cursor: pointer;
}

/* ======== MAIN STACK (NO INTERNAL SCROLL) ======== */
.stack{
  /* Fill the rest of the screen below the topbar */
  height: calc(100% - var(--topbar-h) - 16px);
  display: grid;
  grid-template-rows: auto auto 1fr; /* upper, divider, equipment (flex) */
  gap: 12px; /* Increased gap to push content down */
  overflow: hidden;
  width: 100%;
  box-sizing: border-box;
  padding-top: 8px; /* Additional top padding */
}

/* Make weapons section fit properly without cutoff */
.upper .rightcol {
  max-width: calc(100vw - 120px - 40px); /* Full available width minus left column and padding */
}

@media (min-width: 768px) {
  .upper .rightcol {
    max-width: calc(100vw - 120px - 50px); /* Desktop spacing */
  }
}

/* ======== UPPER: Left Section + Portrait & Weapons (right) ======== */
.upper{
  display: grid;
  grid-template-columns: auto minmax(0, 1fr);
  align-items: start;
  gap: 12px;
  overflow: hidden;
  width: 100%;
  box-sizing: border-box;
}

.left-section {
  display: flex;
  align-items: end;
  gap: 8px;
}

.survival-column {
  display: flex;
  flex-direction: column;
  gap: 3px;
  align-self: start;
  margin-left: 12px; /* Move 10% more to the right */
}

/* Force right column to match equipment grid width and align right */
.rightcol {
  width: 100%;
  max-width: none;
  justify-self: end; /* Align to the right side */
  display: grid;
  justify-items: end; /* Align all child content to the right */
}

@media (min-width: 768px) {
  .rightcol {
    max-width: calc((100vw - 120px - 48px) / 1); /* Desktop spacing */
  }
}

/* Clothing column is sized to match the right column vertically */
.wearables{
  display: flex; flex-direction: column;
  gap: var(--wearables-gap);
  align-self: end; /* bottom align so Rings lines up with Misc */
  max-width: var(--wearable-width);
  flex-shrink: 0; /* prevent shrinking */
}

.slot{
  width: var(--wearable-width);
  height: var(--wearable-height);
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: 8px;
  display: flex; align-items: center; gap: 6px;
  padding: 0 6px;
  color: var(--muted);
  overflow: hidden;
}
.slot:empty::before{ 
  content: attr(data-label); 
  font-size: 10px; 
  opacity: 0.9; 
  font-style: italic;
  letter-spacing: 0.3px;
}
/* Rings: allow up to 5 inline; no wrap */
.slot[data-slot="rings"]{ white-space: nowrap; }

/* Right column */
.rightcol{ 
  display: grid; 
  gap: 6px; 
  max-width: 100%;
  overflow: hidden;
}
.portrait{
  position: relative;
  width: var(--portrait-width);
  height: var(--portrait-height);
  transform: translateX(var(--portrait-offset-x));
  overflow: visible; /* no crop */
  justify-self: end;
  margin-left: auto; /* Push to right */
}

.portrait img.char{
  position: absolute; inset: 0;
  width: 100%; height: 100%;
  object-fit: contain; object-position: center;
  cursor: pointer;
}
.hidden-file{ display:none; }
.weapons{ 
  display: grid; 
  gap: var(--wep-gap);
  width: 100%;
  box-sizing: border-box;
  overflow: hidden;
  max-width: inherit;
  justify-self: end; /* Align to right */
  margin-left: auto; /* Push to right */
}

.wrow.two{ 
  display: grid; 
  grid-template-columns: 1fr 1fr; 
  gap: var(--wep-gap);
  max-width: 100%;
}
.wrow.one{ 
  display: grid; 
  grid-template-columns: 1fr;
  max-width: 100%;
}

.wslot{
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: var(--wep-slot-rad);
  height: var(--wep-slot-h);
  display: grid; place-items: center;
  color: var(--muted); font-size: 11px;
}
.wslot:empty::before{ 
  content: attr(data-label); 
  font-style: italic;
  letter-spacing: 0.2px;
  opacity: 0.85;
}

/* Quiver split */
.qrow{ 
  display: grid; 
  grid-template-columns: 1fr 92px; 
  gap: var(--wep-gap);
  max-width: 100%;
  box-sizing: border-box;
}
.qdrop{
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: var(--wep-slot-rad);
  min-height: var(--quiver-min-h);
  display: flex; flex-wrap: wrap; align-content: flex-start; gap: 4px 8px;
  padding: 4px 6px;
  color: var(--muted); font-size: 11px;
}
.qdrop:empty::before{ content: "Quiver / Ammo"; opacity:.9; }
.qcount{
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: var(--wep-slot-rad);
  min-height: var(--quiver-min-h);
  display: grid; grid-template-columns: auto 1fr auto; gap: 6px; align-items: center; padding: 0 6px;
  color: var(--muted); font-size: 11px;
}
.btn-mini{
  width: 22px; height: 22px; display: grid; place-items: center;
  font-size: 14px; line-height: 1; border-radius: 6px;
  background: linear-gradient(#26231e, #1b1916);
  border: 1px solid #3c311c; color: var(--text);
  cursor: pointer;
  touch-action: auto;
}
#quiverCount{ text-align: center; font-size: 12px; }

/* Divider under Rings */
.divider{
  height: 2px;
  background: linear-gradient(90deg, transparent, #8d7a52aa 40%, #8d7a52aa 60%, transparent);
}

/* ======== EQUIPMENT (fills remaining space; no scroll) ======== */
.equipment{
  display: grid;
  grid-template-columns: repeat(var(--equip-cols), 1fr);
  gap: var(--equip-gap);
  overflow: hidden;
  width: 100%;
  box-sizing: border-box;
}

.eq-card{
  position: relative;
  display: grid;
  grid-template-rows: auto 1fr;
  min-height: var(--equip-min-h);
  gap: 4px;
}

/* Reduce each equipment card height by 10% each (aggressive reduction) */
.eq-card:nth-child(1) { min-height: calc(var(--equip-min-h) * 0.9); } /* Backpack: 90% */
.eq-card:nth-child(2) { min-height: calc(var(--equip-min-h) * 0.8); } /* Additional Bag: 80% */
.eq-card:nth-child(3) { min-height: calc(var(--equip-min-h) * 0.7); } /* Tool Kits: 70% */
.eq-card:nth-child(4) { min-height: calc(var(--equip-min-h) * 0.6); } /* Slot 1: 60% */
.eq-card:nth-child(5) { min-height: calc(var(--equip-min-h) * 0.5); } /* Slot 2: 50% */
.eq-card:nth-child(6) { min-height: calc(var(--equip-min-h) * 0.4); } /* Slot 3: 40% */
.eq-card:nth-child(7) { min-height: calc(var(--equip-min-h) * 0.3); } /* Slot 4: 30% */
.eq-card:nth-child(8) { min-height: calc(var(--equip-min-h) * 0.2); } /* Camp Storage: 20% */

/* Override the default min-height for equipment drops to allow smaller sizing */
.eq-drop {
  min-height: unset;
}

.eq-title{ 
  font-family: 'Cinzel', 'Trajan Pro', 'Times New Roman', serif; 
  font-size: 12px; 
  font-weight: 600;
  letter-spacing: .5px; 
  color: #d4af37; 
  padding-left: 2px; 
  text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}
.eq-drop{
  position: relative;
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: 10px;
  padding: 6px 6px 16px;
  display: flex; flex-wrap: wrap; align-content: flex-start; gap: 4px 8px;
  overflow: hidden;
}

/* Lock buttons for Slots 1–4 - positioned ON the slot */
.lock{
  position: absolute; right: 2px; top: 2px;
  font-size: 10px; line-height: 1;
  padding: 1px 4px; border-radius: 4px;
  background: linear-gradient(#26231e, #1b1916);
  border: 1px solid #3c311c;
  color: var(--text);
  cursor: pointer;
  touch-action: auto;
  z-index: 15; /* higher than LOCKED text */
  pointer-events: auto; /* ensure it's always clickable */
}

.eq-drop.locked{ 
  /* Don't apply filter to whole container - it affects ::after text too */
}
.eq-drop.locked > *:not(.lock):not(.capbar) {
  pointer-events: none; /* prevent dropping items, but allow lock button */
  filter: grayscale(0.9) brightness(0.5); /* Apply filter only to child elements */
}
.eq-drop.locked .capbar {
  filter: grayscale(0.9) brightness(0.5); /* Apply filter to capacity bar too */
}

.eq-drop.locked::after{
  content: "LOCKED"; 
  position: absolute; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%);
  font-family: 'Cinzel', 'Trajan Pro', 'Times New Roman', serif;
  font-size: 18px;
  font-weight: 700;
  letter-spacing: 2px;
  color: #ffc107;
  text-shadow: 
    0 0 12px rgba(255, 193, 7, 1),
    0 0 8px rgba(255, 143, 0, 0.9),
    0 0 4px rgba(255, 235, 59, 0.8),
    0 2px 6px rgba(0, 0, 0, 1),
    2px 2px 0 rgba(0, 0, 0, 0.9);
  opacity: 1;
  z-index: 100; /* Even higher z-index */
  pointer-events: none;
  animation: locked-glow 2s ease-in-out infinite alternate;
  /* Force no filter inheritance */
  filter: none !important;
}

@keyframes locked-glow {
  0% { 
    text-shadow: 
      0 0 12px rgba(255, 193, 7, 1),
      0 0 8px rgba(255, 143, 0, 0.9),
      0 0 4px rgba(255, 235, 59, 0.8),
      0 2px 6px rgba(0, 0, 0, 1);
  }
  100% { 
    text-shadow: 
      0 0 20px rgba(255, 193, 7, 1),
      0 0 16px rgba(255, 143, 0, 1),
      0 0 8px rgba(255, 235, 59, 1),
      0 2px 6px rgba(0, 0, 0, 1);
  }
}

/* Capacity bar (skip for Camp Storage) */
.capbar{
  position: absolute; left: 6px; right: 6px; bottom: 6px; height: 6px;
  background: var(--cap-track);
  border-radius: 999px; overflow: hidden;
  box-shadow: inset 0 1px 0 #000a;
}
.capfill{ height: 100%; width: 0%; background: var(--cap-grad); transition: width 120ms ease-out; }

/* Items – name only + tiny webm icons */
.item{
  font-size: var(--item-font-size);
  line-height: 1.2;
  color: var(--text);
  white-space: nowrap;
  display: inline-flex; align-items: center; gap: 4px;
  cursor: default; /* long-press to drag */
  user-select: none;
  letter-spacing: 0.2px;
  font-weight: 500;
  
  /* Self-contained frame */
  padding: 3px 6px;
  margin: 1px;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid #555;
  border-radius: 4px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
}

.item .tag{ width: 12px; height: 12px; object-fit: cover; border-radius: 2px; }
/* Drag feedback */
.valid{ box-shadow: 0 0 8px #4caf50; border-color: #4caf50; }
.invalid{ box-shadow: 0 0 8px #f44336; border-color: #f44336; }

/* Dialog — same medieval theme; allow normal touch interactions inside */
dialog{
  border: none; border-radius: 12px; padding: 14px;
  background:
    linear-gradient(#1c1a17, #12100f) padding-box,
    linear-gradient(180deg, #cdb27a, #6c532e) border-box;
  border: 1px solid transparent;
  color: var(--text);
  width: min(420px, 92vw);
  max-height: 90svh;
  overflow: auto;
  box-shadow: 0 10px 30px #000c, inset 0 1px 0 #ffffff10;
  touch-action: auto;         /* re-enable scrolling inside dialog if needed */
}
dialog h3 {
  font-family: 'Cinzel', 'Trajan Pro', 'Times New Roman', serif;
  font-weight: 600;
  letter-spacing: 1px;
  color: #d4af37;
  text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  margin-top: 0;
  text-align: center;
  border-bottom: 1px solid #8d7a52;
  padding-bottom: 8px;
}

/* Responsive improvements for very small screens */
@media (max-width: 360px) {
  :root {
    --wearable-width: 90px;
    --wearable-height: 11px;
    --portrait-height: 70px;
    --equip-min-h: 60px; /* Much smaller for mobile */
  }
  .coins { gap: 2px; }
  .coin input { width: 30px; }
  .equipment { gap: 3px; }
}

  .coins { gap: 2px; }
  .coin input { width: 30px; }
  .equipment { gap: 3px; }
}

@media (max-width: 360px) {
  .eq-drop.locked::after {
    font-size: 12px;
    letter-spacing: 1px;
  }
}

@media (orientation: landscape) and (max-height: 500px) {
  :root {
    --portrait-height: 60px;
    --wearable-height: 10px;
    --equip-min-h: 65px; /* Reduced for landscape */
  }
  .stack { gap: 2px; }
  .upper { gap: 4px; }
}

dialog::backdrop{ background: #0009; }

/* Desktop adjustments to prevent overflow */
@media (min-width: 768px) {
  .screen {
    padding: 16px;
    max-width: 100%;
    overflow-x: hidden;
  }
  
  .upper {
    gap: 12px;
  }
  
:root {
    --wearable-width: 120px;
    --portrait-width: 65%;
  }
  
  .upper {
    grid-template-columns: 120px 1fr;
    gap: 16px;
  }
}

@media (max-width: 480px) {
  :root {
    --wearable-width: 140px;
    --portrait-width: 60%;
    --portrait-height: 90px;
  }
}
.field{ margin: 8px 0; }
label{ font-size: 12px; opacity: .9; }
input[type="text"], select, textarea, input[type="number"]{
  width: 100%; background: #141414; color: var(--text);
  border: 1px solid #000; outline: 1px solid #43371e;
  border-radius: 8px; padding: 8px 10px;
  box-shadow: inset 0 6px 16px #0008;
  touch-action: auto;
}


textarea{ min-height: 80px; resize: vertical; }
.actions{ display:flex; gap:8px; justify-content: flex-end; margin-top: 10px; }
.btn{
  padding: 8px 12px; border-radius: 6px; cursor: pointer;
  background: linear-gradient(#26231e, #1b1916) padding-box;
  border: 1px solid #3c311c; color: var(--text);
  font-family: 'Cinzel', serif;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}
/* Water Management Styles */
.water-container {
  display: flex;
  align-items: center;
  gap: 20px;
  margin: 20px 0;
}

.waterskin {
  position: relative;
  width: 100px;
  height: 150px;
  background: linear-gradient(180deg, #8d6e63 0%, #5d4037 100%);
  border-radius: 10px 10px 15px 15px;
  border: 2px solid #3e2723;
  overflow: visible; /* Allow handle to be visible even at 0% */
}

.water-level {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 100%;
  background: 
    radial-gradient(circle at 20% 80%, rgba(255,255,255,0.3) 1px, transparent 3px),
    radial-gradient(circle at 80% 60%, rgba(255,255,255,0.2) 1px, transparent 2px),
    radial-gradient(circle at 40% 40%, rgba(255,255,255,0.4) 1px, transparent 2px),
    linear-gradient(0deg, #0d47a1 0%, #1976d2 50%, #42a5f5 100%);
  transition: height 0.3s ease;
  animation: water-bubble 3s ease-in-out infinite;
}

@keyframes water-bubble {
  0%, 100% { 
    background-position: 0% 0%, 100% 100%, 50% 50%;
  }
  50% { 
    background-position: 100% 100%, 0% 0%, 25% 75%;
  }
}

.water-surface {
  position: absolute;
  top: -1px;
  left: 0;
  right: 0;
  height: 8px;
  background: 
    linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent),
    linear-gradient(90deg, rgba(66,165,245,0.3), rgba(25,118,210,0.5), rgba(66,165,245,0.3));
  animation: water-shimmer 2s ease-in-out infinite, water-wave 1.5s ease-in-out infinite;
}

@keyframes water-wave {
  0%, 100% { transform: scaleY(1); }
  50% { transform: scaleY(1.2); }
}

@keyframes water-slosh {
  0% { transform: skewX(0deg); }
  25% { transform: skewX(-2deg); }
  75% { transform: skewX(2deg); }
  100% { transform: skewX(0deg); }
}

@keyframes water-shimmer {
  0%, 100% { transform: translateX(-100%); }
  50% { transform: translateX(100%); }
}

.drag-handle {
  position: absolute;
  right: -20px;
  top: 0;
  width: 35px;
  height: 25px;
  background: linear-gradient(145deg, #f4d03f, #d4af37);
  border: 2px solid #b8941f;
  border-radius: 8px;
  cursor: grab;
  transition: top 0.2s ease;
  box-shadow: 0 3px 6px rgba(0,0,0,0.4);
  z-index: 20; /* Always on top */
}

.drag-handle::after {
  content: "⚬⚬⚬";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #8d6e63;
  font-size: 8px;
  line-height: 1;
}

.drag-handle:active {
  cursor: grabbing;
}

.measurement-labels {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 120px;
  position: relative;
}

.label {
  position: absolute;
  font-size: 10px;
  color: var(--muted);
  white-space: nowrap;
}

/* Rations Styles */
.ration-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  margin: 4px 0;
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: 6px;
}

.ration-name {
  font-weight: 600;
}

.ration-amount {
  color: var(--muted);
  font-size: 11px;
}

.ration-delete {
  background: #d32f2f;
  color: white;
  border: none;
  padding: 2px 6px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
}

.btn.primary{
  background:
    linear-gradient(#8c733f, #6d552d) padding-box,
    linear-gradient(180deg, #cdb27a, #6c532e) border-box;
  border: 1px solid transparent;
  color: #1a1611; 
  font-weight: 700;
  text-shadow: 0 1px 1px rgba(255,255,255,0.3);
}

/* Spellbook Styles */
.spellbook-screen {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100svh;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  background: #151616 url("assets/Background.png") center/cover no-repeat;
  color: var(--text);
  overflow: hidden;
}

.spellbook-topbar {
  position: sticky;
  top: 0;
  z-index: 100;
  height: 40px;
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: 8px;
  padding: 12px;
  background: rgba(21, 22, 22, 0.95);
  backdrop-filter: blur(5px);
  border-bottom: 1px solid rgba(141, 122, 82, 0.3);
}

/* === NEW, COMPACT LAYOUT + COLLAPSE === */
:root {
  /* add/ensure these exist once */
  --spell-row-min-h: 44px;   /* compact row height */
  --spell-collapsed-h: 32px; /* slim header height when collapsed */
}

.spell-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  padding: 12px;
  overflow-x: hidden;
  flex: 1;
  grid-auto-rows: auto; /* sections size to content/min-height */
}

@media (max-width: 768px) {
  .spell-grid { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 480px) {
  .spell-grid { grid-template-columns: 1fr; gap: 6px; }
}

.spell-section {
  display: flex;
  flex-direction: column;
  /* header (~16px line + paddings) + TWO rows + tiny gaps */
  min-height: calc(var(--spell-row-min-h) * 2 + 48px);
  background: var(--slot-bg);
  border: var(--slot-border);
  border-radius: 8px;
  padding: 8px;
  overflow: hidden;
}

.spell-section h3 {
  font-family: 'Cinzel', serif;
  font-size: 12px;
  color: var(--accent-gold);
  margin: 0 0 4px 0;
  text-align: center;
  border-bottom: 1px solid #8d7a52;
  padding-bottom: 2px;
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}
.spell-section h3::before {
  content: '▼';
  font-size: 10px;
  transition: transform 0.2s;
}
.spell-section.collapsed h3::before {
  transform: rotate(-90deg);
}

/* COLLAPSED: show only header; no inner list; compressed box */
.spell-section.collapsed {
  min-height: var(--spell-collapsed-h) !important;
  height: var(--spell-collapsed-h) !important;
  padding-bottom: 0 !important;
  overflow: hidden !important;
}
.spell-section.collapsed .spell-list {
  display: none !important;
}

.spell-list {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  touch-action: pan-y;
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 0;
  margin: 0;
}

.spell-item {
  background: rgba(0,0,0,0.4);
  border: 1px solid #555;
  border-radius: 4px;
  padding: 4px 32px 4px 8px; /* tight padding */
  cursor: pointer;
  position: relative;
  display: grid;
  grid-template-columns: 1fr auto; /* left: name/school, right: button */
  gap: 0 8px;                /* no vertical gap */
  align-items: center;       /* vertically center content */
  min-height: var(--spell-row-min-h);
  font-size: 10px;
  line-height: 1.2;
}

/* left cell: compact vertical stack (name + school) */
.spell-item > div:first-child {
  display: flex;
  flex-direction: column;
  gap: 0;
}

.spell-name {
  font-weight: 600;
  font-size: 11px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin: 0;
}
.spell-school {
  font-size: 9px;
  opacity: 0.75;
  margin: 0;
}

.spell-show-btn {
  font-size: 10px;
  line-height: 1;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #3c311c;
  background: linear-gradient(#26231e, #1b1916);
  color: var(--text);
  cursor: pointer;
  touch-action: manipulation;
}

.spell-indicators {
  position: absolute;
  top: 2px;
  right: 2px;
  display: flex;
  gap: 2px;
}
.spell-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  font-weight: bold;
  color: white;
}

@media (max-width: 480px) {
  .spell-section {
    min-height: calc(var(--spell-row-min-h) * 2 + 52px);
  }
  .spell-section.collapsed {
    min-height: var(--spell-collapsed-h) !important;
    height: var(--spell-collapsed-h) !important;
  }
}

</style>
</head>
<body>

<main class="screen" role="application" aria-label="Inventory Screen">
  <!-- Top bar -->
<div class="topbar">
    <div class="left-controls">
      <button class="btn-plus" id="addBtn" aria-label="Add Item">+</button>
      <input type="text" id="searchBox" placeholder="Search items..." style="display:none; width: 120px; font-size: 10px; padding: 4px; border-radius: 4px; background: var(--slot-bg); color: var(--text); border: var(--slot-border);">
      <button class="btn-plus" id="searchBtn" aria-label="Search Items" style="width: 24px; height: 24px; font-size: 14px;">🔍</button>
<button class="btn-plus" id="saveBtn" aria-label="Save Data" style="width: 24px; height: 24px; font-size: 12px;" title="Manual Save">💾</button>
    </div>
    <div></div>
<div class="right-controls">
      <div class="coins">
        <div class="coin"><span class="icon gold"></span><input id="gold" type="number" min="0" value="0" aria-label="Gold"></div>
        <div class="coin"><span class="icon silver"></span><input id="silver" type="number" min="0" value="0" aria-label="Silver"></div>
        <div class="coin"><span class="icon copper"></span><input id="copper" type="number" min="0" value="0" aria-label="Copper"></div>
      </div>
    </div>
  </div>

  <div class="stack">
    <!-- Upper: clothing left | portrait + weapons right -->
    <section class="upper">
      <!-- Clothing (left) -->
      <div class="left-section">
        <div class="wearables" id="wearables">
        <div class="slot" data-label="Headwear"    data-slot="headwear"></div>
        <div class="slot" data-label="Cape/Cloak"  data-slot="cape"></div>
        <div class="slot" data-label="Underlay"    data-slot="underlay"></div>
        <div class="slot" data-label="Mesolay"     data-slot="mesolay"></div>
        <div class="slot" data-label="Overlay"     data-slot="overlay"></div>
        <div class="slot" data-label="Gloves"      data-slot="gloves"></div>
        <div class="slot" data-label="Belt"        data-slot="belt"></div>
        <div class="slot" data-label="Trousers"    data-slot="trousers"></div>
        <div class="slot" data-label="Boots"       data-slot="boots"></div>
        <div class="slot" data-label="Rings"       data-slot="rings"></div>
<div class="slot" data-label="Amulet"      data-slot="amulet"></div>
        </div>
        
<div class="survival-column">
          <div class="survival-group">
            <div class="indicator" id="waterIndicator">
              <div class="icon-container">
                <img src="assets/WaterDrop.png" alt="Water" class="survival-icon">
                <div class="fill-overlay water-fill" id="waterFill"></div>
              </div>
            </div>
            <button class="quick-btn" id="quickDrinkBtn" title="Drink 0.25 gal">💧</button>
          </div>
          <div class="survival-group">
            <div class="indicator" id="rationsIndicator">
              <div class="icon-container">
                <img src="assets/Rations.png" alt="Rations" class="survival-icon">
                <div class="fill-overlay rations-fill" id="rationsFill"></div>
              </div>
            </div>
            <button class="quick-btn" id="quickEatBtn" title="Eat 0.25 days">🍞</button>
          </div>
          <div class="survival-group">
            <div class="indicator" id="spellbookIndicator">
              <div class="icon-container">
                <div class="spellbook-icon">📖</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right column: portrait + weapons -->
      <div class="rightcol">
        <figure class="portrait" id="portrait">
          <img class="char" id="charImg" src="assets/Background.png" alt="Tap or drop an image to change portrait" />
          <input id="fileInput" class="hidden-file" type="file" accept="image/*" />
        </figure>

        <div class="weapons" id="weapons">
          <div class="wrow two">
            <div class="wslot" data-weapon="main" data-label="Main Hand"></div>
            <div class="wslot" data-weapon="off"  data-label="Off Hand"></div>
          </div>
          <div class="wrow one">
            <div class="wslot" data-weapon="twohand" data-label="Two-Handed / Ranged"></div>
          </div>
          <div class="qrow">
            <div class="qdrop" id="quiverDrop" data-weapon="quiver"></div>
            <div class="qcount">
              <button type="button" class="btn-mini" id="ammoMinus">−</button>
              <span id="quiverCount">0</span>
              <button type="button" class="btn-mini" id="ammoPlus">+</button>
            </div>
          </div>
          <div class="wrow one">
            <div class="wslot" data-weapon="misc" data-label="Misc / Instrument (≤ Medium)"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Divider -->
    <div class="divider"></div>

    <!-- Equipment (fills remaining space; no scroll) -->
    <section class="equipment" id="equipment">
      <div class="eq-card">
        <div class="eq-title">Backpack</div>
        <div class="eq-drop" data-eq="backpack"><div class="capbar"><div class="capfill"></div></div></div>
      </div>

      <div class="eq-card">
        <div class="eq-title">Additional Bag</div>
        <div class="eq-drop" data-eq="addbag"><div class="capbar"><div class="capfill"></div></div></div>
      </div>

      <div class="eq-card">
        <div class="eq-title">Tool Kits</div>
        <div class="eq-drop" data-eq="toolkits"><div class="capbar"><div class="capfill"></div></div></div>
      </div>

<div class="eq-card">
        <div class="eq-title">Slot 1</div>
        <div class="eq-drop locked" data-eq="slot1">
          <button class="lock" data-lock-for="slot1">🔒</button>
          <div class="capbar"><div class="capfill"></div></div>
        </div>
      </div>

      <div class="eq-card">
        <div class="eq-title">Slot 2</div>
        <div class="eq-drop locked" data-eq="slot2">
          <button class="lock" data-lock-for="slot2">🔒</button>
          <div class="capbar"><div class="capfill"></div></div>
        </div>
      </div>

      <div class="eq-card">
        <div class="eq-title">Slot 3</div>
        <div class="eq-drop locked" data-eq="slot3">
          <button class="lock" data-lock-for="slot3">🔒</button>
          <div class="capbar"><div class="capfill"></div></div>
        </div>
      </div>

      <div class="eq-card">
        <div class="eq-title">Slot 4</div>
        <div class="eq-drop locked" data-eq="slot4">
          <button class="lock" data-lock-for="slot4">🔒</button>
          <div class="capbar"><div class="capfill"></div></div>
        </div>
      </div>

      <!-- Camp Storage (unlimited) -->
      <div class="eq-card">
        <div class="eq-title">Camp Storage (Unlimited)</div>
        <div class="eq-drop" data-eq="camp"></div>
      </div>
    </section>
  </div>
</main>

<!-- Add / View Item (medieval theme) -->
<dialog id="itemDialog">
  <form id="itemForm">
    <h3 id="dlgTitle">Add Item</h3>
    <div class="field">
      <label for="itemName">Name</label>
      <input id="itemName" type="text" required placeholder="e.g., Ring of Protection / Iron Arrows" />
    </div>
    <div class="field">
      <label for="itemSize">Size</label>
      <select id="itemSize" required>
        <option value="Small" selected>Small</option>
        <option value="Medium">Medium</option>
        <option value="Large">Large</option>
      </select>
    </div>
    <div class="field">
      <label for="itemQty">Quantity (for ammo stacks)</label>
      <input id="itemQty" type="number" min="1" value="1" />
    </div>
    <div class="field">
      <label><input type="checkbox" id="needsAttune" /> Needs attunement</label><br />
      <label><input type="checkbox" id="isCursed" /> Cursed</label>
    </div>
    <div class="field">
      <label for="itemDesc">Description (optional)</label>
      <textarea id="itemDesc" placeholder="What does it do?"></textarea>
    </div>
    <div class="actions">
      <button type="button" class="btn" id="cancelBtn">Cancel</button>
      <button type="button" class="btn" id="deleteBtn" style="display:none">Delete</button>
      <button type="button" class="btn" id="sortBtn" style="display:none">Sort Zone</button>
      <button type="submit" class="btn primary" id="saveBtn">Save</button>
    </div>
  </form>
</dialog>

<!-- Water Management Dialog -->
<dialog id="waterDialog">
  <div id="waterMainMenu">
    <h3>Water Management</h3>
    <p>Current: <span id="currentWater">1.0</span> / 1.0 gallons</p>
    <div class="actions">
      <button type="button" class="btn" id="drinkWaterBtn">Drink (0.25 gal)</button>
      <button type="button" class="btn primary" id="fillWaterBtn">Fill Waterskin</button>
      <button type="button" class="btn" id="cancelWaterBtn">Cancel</button>
    </div>
  </div>
  
  <div id="waterFillMenu" style="display:none;">
    <h3>Fill Waterskin</h3>
    <div class="water-container">
      <div class="waterskin" id="waterskin">
        <div class="water-level" id="waterLevel"></div>
        <div class="water-surface" id="waterSurface"></div>
        <div class="drag-handle" id="dragHandle"></div>
      </div>
      <div class="measurement-labels">
        <div class="label" style="bottom: 75%;">1.0 gal</div>
        <div class="label" style="bottom: 50%;">0.5 gal</div>
        <div class="label" style="bottom: 25%;">0.25 gal</div>
        <div class="label" style="bottom: 0%;">Empty</div>
      </div>
    </div>
    <p>Drag the handle to set water level</p>
    <div class="actions">
      <button type="button" class="btn" id="backToWaterBtn">Back</button>
      <button type="button" class="btn primary" id="confirmWaterBtn">Confirm</button>
    </div>
  </div>
</dialog>

<!-- Rations Management Dialog -->
<dialog id="rationsDialog">
  <div id="rationsMainMenu">
    <h3>Rations Management</h3>
    <p>Current: <span id="currentRations">0.0</span> / 7.0 days</p>
    <div class="actions">
      <button type="button" class="btn" id="eatRationsBtn">Eat (1 day)</button>
      <button type="button" class="btn primary" id="addRationsBtn">Add Rations</button>
      <button type="button" class="btn" id="cancelRationsBtn">Cancel</button>
    </div>
  </div>
  
  <div id="addRationMenu" style="display:none;">
    <h3>Add Rations</h3>
    <div class="field">
      <label for="rationName">Ration Name</label>
      <input id="rationName" type="text" placeholder="e.g., Trail Bread, Dried Meat" />
    </div>
    <div class="field">
      <label for="rationAmount">Amount</label>
      <select id="rationAmount">
        <option value="0.25">Quarter Day (0.25)</option>
        <option value="0.5">Half Day (0.5)</option>
        <option value="1" selected>Full Day (1.0)</option>
      </select>
    </div>
    <div class="actions">
      <button type="button" class="btn" id="cancelAddRationBtn">Back</button>
      <button type="button" class="btn primary" id="confirmAddRationBtn">Add</button>
    </div>
  </div>
</dialog>

<!-- Spellbook Page (hidden initially) -->
<div id="spellbookPage" style="display: none;">
  <div class="spellbook-screen">
    <div class="spellbook-topbar">
      <button class="btn" id="backToInventoryBtn">← Back to Inventory</button>
      <div></div>
      <button class="btn primary" id="addSpellBtn">+ Add Spell</button>
    </div>
    
    <div class="spell-grid">
      <div class="spell-section" data-level="cantrip">
        <h3>Cantrips</h3>
        <div class="spell-list" id="cantrips"></div>
      </div>
      <div class="spell-section" data-level="1">
        <h3>1st Level</h3>
        <div class="spell-list" id="level1"></div>
      </div>
      <div class="spell-section" data-level="2">
        <h3>2nd Level</h3>
        <div class="spell-list" id="level2"></div>
      </div>
      <div class="spell-section" data-level="3">
        <h3>3rd Level</h3>
        <div class="spell-list" id="level3"></div>
      </div>
      <div class="spell-section" data-level="4">
        <h3>4th Level</h3>
        <div class="spell-list" id="level4"></div>
      </div>
      <div class="spell-section" data-level="5">
        <h3>5th Level</h3>
        <div class="spell-list" id="level5"></div>
      </div>
      <div class="spell-section" data-level="6">
        <h3>6th Level</h3>
        <div class="spell-list" id="level6"></div>
      </div>
      <div class="spell-section" data-level="7">
        <h3>7th Level</h3>
        <div class="spell-list" id="level7"></div>
      </div>
      <div class="spell-section" data-level="8">
        <h3>8th Level</h3>
        <div class="spell-list" id="level8"></div>
      </div>
      <div class="spell-section" data-level="9">
        <h3>9th Level</h3>
        <div class="spell-list" id="level9"></div>
      </div>
    </div>
  </div>
</div>

<!-- Add/Edit Spell Dialog -->
<dialog id="spellDialog">
  <form id="spellForm">
    <h3 id="spellDlgTitle">Add Spell</h3>
    <div class="field">
      <label for="spellName">Spell Name</label>
      <div style="display: flex; gap: 8px;">
        <input id="spellName" type="text" required placeholder="e.g., Fireball" style="flex: 1;" />
        <button type="button" class="btn" id="autoFillBtn">Auto Fill</button>
      </div>
    </div>
    <div class="field">
      <label for="spellLevel">Level</label>
      <select id="spellLevel" required>
        <option value="cantrip">Cantrip</option>
        <option value="1">1st Level</option>
        <option value="2">2nd Level</option>
        <option value="3">3rd Level</option>
        <option value="4">4th Level</option>
        <option value="5">5th Level</option>
        <option value="6">6th Level</option>
        <option value="7">7th Level</option>
        <option value="8">8th Level</option>
        <option value="9">9th Level</option>
      </select>
    </div>
    <div class="field">
      <label for="spellSchool">School</label>
      <select id="spellSchool">
        <option value="">Select School</option>
        <option value="Abjuration">Abjuration</option>
        <option value="Conjuration">Conjuration</option>
        <option value="Divination">Divination</option>
        <option value="Enchantment">Enchantment</option>
        <option value="Evocation">Evocation</option>
        <option value="Illusion">Illusion</option>
        <option value="Necromancy">Necromancy</option>
        <option value="Transmutation">Transmutation</option>
      </select>
    </div>
    <div class="field">
      <label for="castingTime">Casting Time</label>
      <input id="castingTime" type="text" placeholder="e.g., 1 action" />
    </div>
    <div class="field">
      <label for="spellRange">Range</label>
      <input id="spellRange" type="text" placeholder="e.g., 150 feet" />
    </div>
    <div class="field">
      <label for="spellComponents">Components</label>
      <input id="spellComponents" type="text" placeholder="e.g., V, S, M (a tiny ball of bat guano)" />
    </div>
    <div class="field">
      <label for="spellDuration">Duration</label>
      <input id="spellDuration" type="text" placeholder="e.g., Instantaneous" />
    </div>
    <div class="field">
      <label><input type="checkbox" id="spellConcentration" /> Requires Concentration</label>
    </div>
    <div class="field">
      <label for="spellDescription">Description</label>
      <textarea id="spellDescription" placeholder="Spell description and effects..."></textarea>
    </div>
    <div class="actions">
      <button type="button" class="btn" id="cancelSpellBtn">Cancel</button>
      <button type="button" class="btn" id="deleteSpellBtn" style="display:none">Delete</button>
      <button type="submit" class="btn primary" id="saveSpellBtn">Save</button>
    </div>
  </form>
</dialog>

<!-- Read-only Spell Text Dialog -->
<dialog id="spellTextDialog">
  <h3 id="spellTextTitle">Spell</h3>
  <div id="spellTextBody" style="font-size: 12px; line-height: 1.4; white-space: pre-wrap;"></div>
  <div class="actions" style="margin-top: 12px; display:flex; justify-content:flex-end; gap:8px;">
    <button type="button" class="btn" id="closeSpellTextBtn">Close</button>
  </div>
</dialog>



<script>
// <dialog> fallback (older Safari)
if (!('HTMLDialogElement' in window) || !('showModal' in HTMLDialogElement.prototype)) {
  document.querySelectorAll('dialog').forEach((dlg) => {
    dlg.showModal = function(){ this.setAttribute('open',''); };
    dlg.close = function(){ this.removeAttribute('open'); };
  });
}

/* ---------- ICON PATHS ---------- */
const ICON_RUNE  = "assets/Rune02Loop_01_04_Regular_Purple_400x400.webm";
const ICON_CHAIN = "assets/MarkerChainDiamond01_01_Regular_Red_Loop_400x400.webm";


/* ========== DATA PERSISTENCE ========== */

// Save all app data to localStorage
function saveAppData() {
  console.log('Attempting to save data...');
  console.log('Is PWA?', window.matchMedia('(display-mode: standalone)').matches);
  console.log('User agent:', navigator.userAgent);
  
  // Check if localStorage is available
  if (typeof(Storage) === "undefined") {
    console.error('localStorage not supported');
    alert('Storage not supported on this device');
    return;
  }
  
  // Test localStorage write/read
  try {
    localStorage.setItem('test_key', 'test_value');
    const testRead = localStorage.getItem('test_key');
    console.log('localStorage test:', testRead === 'test_value' ? 'PASSED' : 'FAILED');
    localStorage.removeItem('test_key');
  } catch (e) {
    console.error('localStorage test failed:', e);
    alert('localStorage not working: ' + e.message);
    return;
  }
  
  try {
    const appData = {
      // Items data
      items: Array.from(items.entries()).map(([id, obj]) => ({
        id,
        data: obj.data,
        parentSelector: getElementSelector(obj.el.parentElement)
      })),
      idCounter,
      
      // Coins
      coins: {
        gold: document.getElementById('gold').value,
        silver: document.getElementById('silver').value,
        copper: document.getElementById('copper').value
      },
      
      // Survival resources
      survival: {
        waterLevel,
        rationsDays,
        rationsStock
      },
      
      // Spells
      spells: Array.from(spells.entries()).map(([id, spell]) => ({
        id,
        data: spell.data
      })),
      spellIdCounter,
      
// Portrait image (as data URL if custom)
      portraitSrc: document.getElementById('charImg').src.startsWith('data:') ? 
                   document.getElementById('charImg').src : null,
      
      // Quiver count
      quiverCount: parseInt(document.getElementById('quiverCount').textContent) || 0,
      
      // Save timestamp
      savedAt: Date.now()
    };
    
const dataString = JSON.stringify(appData);
    console.log('Total save data size:', dataString.length, 'characters');
    
    // Check if data is too large for localStorage
    if (dataString.length > 5000000) { // 5MB limit
      console.warn('Data might be too large for localStorage');
      // Remove portrait to save space
      delete appData.portraitSrc;
      console.log('Removed portrait, new size:', JSON.stringify(appData).length);
      alert('Image too large for storage - saving without portrait');
    }
    
    localStorage.setItem('dnd_inventory_data', JSON.stringify(appData));
    console.log('App data saved successfully');
    
    // Verify save worked
    const verification = localStorage.getItem('dnd_inventory_data');
    if (verification) {
      console.log('Save verified - data exists in localStorage');
    } else {
      console.error('Save failed - no data found after save attempt');
      alert('Save failed - localStorage not working');
    }
  } catch (error) {
    console.error('Failed to save app data:', error);
  }
}

// Load all app data from localStorage
function loadAppData() {
  try {
    console.log('Attempting to load data...');
    const saved = localStorage.getItem('dnd_inventory_data');
    console.log('Raw saved data:', saved ? 'Data found' : 'No data found');
    if (!saved) {
      console.log('No saved data available');
      return false;
    }
    
    const appData = JSON.parse(saved);
    console.log('Loading app data from:', new Date(appData.savedAt));
    
    // Clear existing data
    items.clear();
    spells.clear();
    document.querySelectorAll('.item').forEach(el => el.remove());
    document.querySelectorAll('.spell-item').forEach(el => el.remove());
    
    // Restore counters
    if (appData.idCounter) idCounter = appData.idCounter;
    if (appData.spellIdCounter) spellIdCounter = appData.spellIdCounter;
    
    // Restore coins
    if (appData.coins) {
      document.getElementById('gold').value = appData.coins.gold || 0;
      document.getElementById('silver').value = appData.coins.silver || 0;
      document.getElementById('copper').value = appData.coins.copper || 0;
    }
    
    // Restore survival resources
    if (appData.survival) {
      waterLevel = appData.survival.waterLevel || 1.0;
      rationsDays = appData.survival.rationsDays || 0.0;
      rationsStock = appData.survival.rationsStock || [];
      updateWaterDisplay();
      updateRationsDisplay();
    }
    
// Restore portrait
    if (appData.portraitSrc && appData.portraitSrc.startsWith('data:')) {
      console.log('Restoring portrait, data URL length:', appData.portraitSrc.length);
      console.log('Portrait data starts with:', appData.portraitSrc.substring(0, 50));
      
      // Test the saved image before setting it
      const testImg = new Image();
      testImg.onload = function() {
        console.log('Saved portrait validated successfully');
        document.getElementById('charImg').src = appData.portraitSrc;
      };
      testImg.onerror = function() {
        console.error('Saved portrait is corrupted, using default');
        document.getElementById('charImg').src = 'assets/Background.png';
      };
      testImg.src = appData.portraitSrc;
    } else {
      console.log('No valid portrait saved, using default');
      document.getElementById('charImg').src = 'assets/Background.png';
    }
    
    // Restore items
    if (appData.items) {
      appData.items.forEach(itemData => {
        const el = document.createElement('span');
        el.className = 'item';
        el.dataset.id = itemData.id;
        updateItemEl(el, itemData.data);
        wireItem(el);
        
        const parent = document.querySelector(itemData.parentSelector);
        if (parent) {
          parent.appendChild(el);
        } else {
          // Fallback to first equipment zone
          document.querySelector('.eq-drop').appendChild(el);
        }
        
        items.set(itemData.id, { el, data: itemData.data });
      });
    }
    
    // Restore spells
    if (appData.spells) {
      appData.spells.forEach(spellData => {
        const element = createSpellElement(spellData.data, spellData.id);
        const listId = spellData.data.level === 'cantrip' ? 'cantrips' : `level${spellData.data.level}`;
        const spellList = document.getElementById(listId);
        if (spellList) {
          spellList.appendChild(element);
          spells.set(spellData.id, { data: spellData.data, element });
        }
      });
    }
    
    // Update UI
    updateAllCaps();
    updateQuiverCounter();
    
    return true;
  } catch (error) {
    console.error('Failed to load app data:', error);
    return false;
  }
}

// Helper to get CSS selector for an element
function getElementSelector(element) {
  if (!element) return '';
  
  if (element.id) return `#${element.id}`;
  if (element.className) {
    const classes = element.className.split(' ').filter(c => c);
    if (classes.length > 0) return `.${classes.join('.')}`;
  }
  if (element.dataset.eq) return `[data-eq="${element.dataset.eq}"]`;
  if (element.dataset.slot) return `[data-slot="${element.dataset.slot}"]`;
  if (element.dataset.weapon) return `[data-weapon="${element.dataset.weapon}"]`;
  
  return element.tagName.toLowerCase();
}

// Auto-save on data changes (debounced)
let saveTimeout;
function scheduleSave() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(saveAppData, 500); // Save 500ms after last change
}

// Manual save function for immediate saves
function forceSave() {
  clearTimeout(saveTimeout);
  saveAppData();
}

// Alternative storage using IndexedDB for PWAs
let useIndexedDB = false;

function initStorage() {
  // Try localStorage first
  try {
    localStorage.setItem('storage_test', 'test');
    localStorage.removeItem('storage_test');
    console.log('Using localStorage');
    return;
  } catch (e) {
    console.log('localStorage failed, trying IndexedDB');
    useIndexedDB = true;
  }
  
  // Setup IndexedDB fallback
  if ('indexedDB' in window) {
    setupIndexedDB();
  } else {
    alert('No storage available on this device');
  }
}

function setupIndexedDB() {
  const request = indexedDB.open('dnd_inventory_db', 1);
  
  request.onupgradeneeded = function(e) {
    const db = e.target.result;
    if (!db.objectStoreNames.contains('gameData')) {
      db.createObjectStore('gameData', { keyPath: 'key' });
    }
  };
  
  request.onsuccess = function(e) {
    window.inventoryDB = e.target.result;
    console.log('IndexedDB ready');
  };
  
  request.onerror = function(e) {
    console.error('IndexedDB failed:', e);
    alert('Storage setup failed');
  };
}

// Modified save function that uses IndexedDB if needed
async function saveAppDataAlt() {
  if (!useIndexedDB) {
    return saveAppData();
  }
  
  // Use IndexedDB
  if (!window.inventoryDB) {
    console.error('IndexedDB not ready');
    return;
  }
  
  const appData = {
    items: Array.from(items.entries()).map(([id, obj]) => ({
      id,
      data: obj.data,
      parentSelector: getElementSelector(obj.el.parentElement)
    })),
    idCounter,
    coins: {
      gold: document.getElementById('gold').value,
      silver: document.getElementById('silver').value,
      copper: document.getElementById('copper').value
    },
    survival: {
      waterLevel,
      rationsDays,
      rationsStock
    },
    spells: Array.from(spells.entries()).map(([id, spell]) => ({
      id,
      data: spell.data
    })),
    spellIdCounter,
    portraitSrc: document.getElementById('charImg').src !== 'assets/Background.png' ? 
                 document.getElementById('charImg').src : null,
    quiverCount: parseInt(document.getElementById('quiverCount').textContent) || 0,
    savedAt: Date.now()
  };
  
  const transaction = window.inventoryDB.transaction(['gameData'], 'readwrite');
  const store = transaction.objectStore('gameData');
  
  try {
    await store.put({ key: 'dnd_inventory_data', data: appData });
    console.log('Data saved to IndexedDB');
  } catch (e) {
    console.error('IndexedDB save failed:', e);
  }
}

/* Portrait image picker / drop */
const portrait = document.getElementById('portrait');
const charImg  = document.getElementById('charImg');
const fileInput= document.getElementById('fileInput');
portrait.addEventListener('click', () => fileInput.click());

/// Helper function to convert file to data URL and save
function handleImageFile(file) {
  if (!file || !file.type.startsWith('image/')) return;
  
  // Check file size (limit to 1MB to prevent localStorage issues)
  if (file.size > 1024 * 1024) {
    alert('Image too large. Please use an image under 1MB.');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const dataUrl = e.target.result;
    console.log('Image loaded, data URL length:', dataUrl.length);
    console.log('Data URL starts with:', dataUrl.substring(0, 50));
    
    // Test if image loads properly
    const testImg = new Image();
    testImg.onload = function() {
      console.log('Image validated successfully');
      charImg.src = dataUrl;
      scheduleSave(); // Auto-save after image change
    };
    testImg.onerror = function() {
      console.error('Image validation failed');
      alert('Invalid image file');
    };
    testImg.src = dataUrl;
  };
  reader.onerror = function() {
    console.error('Failed to read image file');
    alert('Failed to read image file');
  };
  reader.readAsDataURL(file);
}

fileInput.addEventListener('change', e => {
  const f = e.target.files?.[0]; 
  if (f) handleImageFile(f);
});

['dragover','drop'].forEach(evt => portrait.addEventListener(evt, e => e.preventDefault()));
portrait.addEventListener('drop', e => {
  const f = e.dataTransfer.files?.[0]; 
  if (f) handleImageFile(f);
});
['dragover','drop'].forEach(evt => portrait.addEventListener(evt, e => e.preventDefault()));
portrait.addEventListener('drop', e => {
  const f = e.dataTransfer.files?.[0]; if(!f || !f.type.startsWith('image/')) return;
  charImg.src = URL.createObjectURL(f);
});

/* Coins */
['gold','silver','copper'].forEach(id => {
  const el = document.getElementById(id);
  el.addEventListener('input', () => { 
    if(el.value < 0) el.value = 0; 
    scheduleSave(); // Auto-save coin changes
  });
});

/* Add / edit / delete items */
const itemDialog = document.getElementById('itemDialog');
const itemForm   = document.getElementById('itemForm');
const addBtn     = document.getElementById('addBtn');
const cancelBtn  = document.getElementById('cancelBtn');
const deleteBtn  = document.getElementById('deleteBtn');
const dlgTitle   = document.getElementById('dlgTitle');

let editingId = null;
let idCounter = 1;
const items = new Map(); // id -> {el, data}

addBtn.addEventListener('click', () => openAddDialog());
/* Search functionality */
const searchBtn = document.getElementById('searchBtn');
const searchBox = document.getElementById('searchBox');
let searchVisible = false;

searchBtn.addEventListener('click', () => {
  searchVisible = !searchVisible;
  searchBox.style.display = searchVisible ? 'block' : 'none';
  if(searchVisible) {
    searchBox.focus();
  } else {
    searchBox.value = '';
    showAllItems();
  }
});

searchBox.addEventListener('input', e => {
  const query = e.target.value.toLowerCase().trim();
  filterItems(query);
});

// Manual save button
document.getElementById('saveBtn').addEventListener('click', () => {
  forceSave();
  // Visual feedback
  const btn = document.getElementById('saveBtn');
  const original = btn.style.background;
  btn.style.background = '#4caf50';
  setTimeout(() => btn.style.background = original, 200);
});


/* Spellbook: category collapse + read-only description modal (delegated, plain JS) */
document.addEventListener('click', function(e) {
  // Collapse/expand category by tapping its header
  var header = e.target && e.target.closest ? e.target.closest('h3') : null;
  if (header && header.parentElement && header.parentElement.classList.contains('spell-section')) {
    e.preventDefault();
    e.stopPropagation();
    var section = header.parentElement;
    var nowCollapsed = section.classList.toggle('collapsed');
    header.setAttribute('aria-expanded', String(!nowCollapsed));
    return;
  }

  // Open read-only description modal
  var showBtn = e.target && e.target.closest ? e.target.closest('.spell-show-btn') : null;
  if (showBtn) {
    e.preventDefault();
    e.stopPropagation();

    var item = showBtn.closest('.spell-item');
    if (!item) return;

    var title = item.dataset.spellName || 'Spell';
    var body  = item.dataset.description || 'No description available.';

    var dlg = document.getElementById('spellTextDialog');
    document.getElementById('spellTextTitle').textContent = title;
    document.getElementById('spellTextBody').textContent  = body;

    try { dlg.showModal(); } catch (err) { dlg.setAttribute('open',''); }
    return;
  }
});

// Close button for text dialog
(function() {
  var btn = document.getElementById('closeSpellTextBtn');
  if (btn) {
    btn.addEventListener('click', function() {
      var dlg = document.getElementById('spellTextDialog');
      try { dlg.close(); } catch (err) { dlg.removeAttribute('open'); }
    });
  }
})();

// Give headers button semantics once at startup (plain JS)
(function initSpellHeaders(){
  var headers = document.querySelectorAll('.spell-section > h3');
  for (var i = 0; i < headers.length; i++) {
    headers[i].setAttribute('role', 'button');
    headers[i].setAttribute('tabindex', '0');
    headers[i].setAttribute('aria-expanded', 'true');
  }
})();




// Close button for text dialog
document.getElementById('closeSpellTextBtn')?.addEventListener('click', () => {
  const dlg = document.getElementById('spellTextDialog');
  try { dlg.close(); } catch { dlg.removeAttribute('open'); }
});




function filterItems(query) {
  document.querySelectorAll('.item').forEach(item => {
    const data = items.get(item.dataset.id)?.data;
    if(!data) return;
    
    const matches = !query || 
      data.name.toLowerCase().includes(query) ||
      data.desc.toLowerCase().includes(query) ||
      data.size.toLowerCase().includes(query);
    
    item.style.opacity = matches ? '1' : '0.3';
    item.style.filter = matches ? 'none' : 'grayscale(1)';
  });
}

function showAllItems() {
  document.querySelectorAll('.item').forEach(item => {
    item.style.opacity = '1';
    item.style.filter = 'none';
  });
}
cancelBtn.addEventListener('click', () => itemDialog.close());
deleteBtn.addEventListener('click', () => {
  if(!editingId) return;
  const obj = items.get(editingId);
  if(obj){ 
    obj.el.remove(); 
    items.delete(editingId); 
    updateAllCaps(); 
    updateQuiverCounter(); 
    scheduleSave(); // Auto-save after deleting
  }
  itemDialog.close();
});

const sortBtn = document.getElementById('sortBtn');
sortBtn.addEventListener('click', () => {
  if(!editingId) return;
  const obj = items.get(editingId);
  if(obj && obj.el.parentElement) {
    sortItemsInZone(obj.el.parentElement);
  }
});

function sortItemsInZone(zone) {
  const itemElements = Array.from(zone.querySelectorAll('.item'));
  const itemsData = itemElements.map(el => ({
    el,
    data: items.get(el.dataset.id)
  })).filter(item => item.data);
  
  // Sort by: cursed items last, then by size (small first), then alphabetically
  itemsData.sort((a, b) => {
    if(a.data.cursed !== b.data.cursed) return a.data.cursed ? 1 : -1;
    if(a.data.size !== b.data.size) {
      const sizeOrder = {Small: 0, Medium: 1, Large: 2};
      return sizeOrder[a.data.size] - sizeOrder[b.data.size];
    }
    return a.data.name.localeCompare(b.data.name);
  });
  
  // Re-append in sorted order
  itemsData.forEach(item => zone.appendChild(item.el));
}

function openAddDialog(){
  editingId = null;
  dlgTitle.textContent = 'Add Item';
  deleteBtn.style.display = 'none';
  sortBtn.style.display = 'none';
  itemForm.reset();
  itemDialog.showModal();
}

function openEditDialog(id){
  const obj = items.get(id); if(!obj) return;
  editingId = id;
  dlgTitle.textContent = 'Item Details';
  deleteBtn.style.display = 'inline-block';
  sortBtn.style.display = obj.el.parentElement?.querySelectorAll('.item').length > 1 ? 'inline-block' : 'none';
  document.getElementById('itemName').value = obj.data.name;
  document.getElementById('itemSize').value = obj.data.size;
  document.getElementById('itemQty').value  = obj.data.count || 1;
  document.getElementById('needsAttune').checked = obj.data.attune;
  document.getElementById('isCursed').checked = obj.data.cursed;
  document.getElementById('itemDesc').value = obj.data.desc || '';
  itemDialog.showModal();
}

itemForm.addEventListener('submit', e => {
  e.preventDefault();
  const name = document.getElementById('itemName').value.trim();
  if(!name) return;

  const data = {
    name,
    nameLower: name.toLowerCase(),
    size: document.getElementById('itemSize').value,
    count: Math.max(1, parseInt(document.getElementById('itemQty').value || '1', 10)),
    attune: document.getElementById('needsAttune').checked,
    cursed: document.getElementById('isCursed').checked,
    desc: document.getElementById('itemDesc').value.trim()
  };
  data.isAmmo = /arrow|bolt|bullet|ammo/i.test(data.nameLower);

  if(editingId){
    const obj = items.get(editingId);
    if(obj){
      obj.data = data;
      updateItemEl(obj.el, data);
      updateAllCaps(); updateQuiverCounter();
    }
  } else {
    const id = 'it' + (idCounter++);
    const el = document.createElement('span');
    el.className = 'item'; el.dataset.id = id;
    updateItemEl(el, data);
    wireItem(el);
    const firstDrop = findFirstDropTarget(data);
    (firstDrop || document.querySelector('.equipment')).appendChild(el);
items.set(id, { el, data });
    tryMergeInZone(el.parentElement, id);
    updateAllCaps(); updateQuiverCounter();
    scheduleSave(); // Auto-save after adding item
  }
  itemDialog.close();
});

/* Render: name only + webm icons if needed */
function updateItemEl(el, data){
  el.innerHTML = '';
  const nameSpan = document.createElement('span');
  nameSpan.textContent = data.name + (data.isAmmo && data.count>1 ? ` x${data.count}` : '');
  el.appendChild(nameSpan);

  if (data.attune) {
    const v = document.createElement("video");
    v.src = ICON_RUNE;
    v.className = "tag"; v.autoplay = true; v.loop = true; v.muted = true; v.playsInline = true;
    el.appendChild(v);
  }
  if (data.cursed) {
    const v = document.createElement("video");
    v.src = ICON_CHAIN;
    v.className = "tag"; v.autoplay = true; v.loop = true; v.muted = true; v.playsInline = true;
    el.appendChild(v);
  }
  el.title = data.desc || '';
}

/* Long-press drag (tap to edit) */
let dragId = null, dragGhost = null, longPressTimer = null;
const LONG_PRESS_MS = 220;

function wireItem(el){
  el.addEventListener('click', () => { if(!dragId) openEditDialog(el.dataset.id); });

const startDrag = (x, y) => {
    dragId = el.dataset.id;
    dragGhost = el.cloneNode(true);
    dragGhost.style.position = 'fixed';
    dragGhost.style.pointerEvents = 'none';
    dragGhost.style.opacity = '0.8';
    dragGhost.style.transform = 'translate(-50%, -50%) scale(1.1)';
    dragGhost.style.zIndex = '9999';
    dragGhost.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
    document.body.appendChild(dragGhost);
    moveGhost(x, y);
    markDrops(dragId, true);
    if(navigator.vibrate) navigator.vibrate(50); // Haptic feedback
  };
  const moveGhost = (x, y) => {
    if(dragGhost){ dragGhost.style.left = x+'px'; dragGhost.style.top = y+'px'; }
  };
  const endDrag = (x, y) => {
    const target = document.elementFromPoint(x, y);
    const drop = target?.closest('.eq-drop, .slot, .wslot, .qdrop');
    const obj = items.get(dragId);
    if(drop && obj && canAccept(drop, obj.data)){
      drop.appendChild(obj.el);
      tryMergeInZone(drop, dragId);
    }
    cleanupDrag();
    updateAllCaps(); updateQuiverCounter();
  };
  const cleanupDrag = () => {
    if(dragGhost) dragGhost.remove();
    dragGhost = null; dragId = null;
    markDrops(null, false);
  };

  // Mouse
  el.addEventListener('mousedown', (e) => {
    if(e.button !== 0) return;
    e.preventDefault();
    clearTimeout(longPressTimer);
    longPressTimer = setTimeout(() => startDrag(e.clientX, e.clientY), LONG_PRESS_MS);
    const mm = (ev) => { if(dragId) moveGhost(ev.clientX, ev.clientY); };
    const mu = (ev) => { clearTimeout(longPressTimer); document.removeEventListener('mousemove', mm); document.removeEventListener('mouseup', mu); if(dragId) endDrag(ev.clientX, ev.clientY); };
    document.addEventListener('mousemove', mm);
    document.addEventListener('mouseup', mu);
  });

  // Touch — with touch-action:none on .screen, no page scroll during drag
  el.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    clearTimeout(longPressTimer);
    longPressTimer = setTimeout(() => startDrag(t.clientX, t.clientY), LONG_PRESS_MS);
  });
  el.addEventListener('touchmove', (e) => {
    if(!dragId) return;
    const t = e.touches[0];
    moveGhost(t.clientX, t.clientY);
    e.preventDefault(); /* extra safety: no scroll while dragging */
  }, {passive:false});
  el.addEventListener('touchend', (e) => {
    clearTimeout(longPressTimer);
    if(!dragId) return;
    const t = e.changedTouches[0];
    endDrag(t.clientX, t.clientY);
  });
}

/* Rules & helpers */
const SIZE_UNITS = { Small:1, Medium:5, Large:15 };

function currentUnits(zone){
  let total = 0, med=0, large=0;
  zone.querySelectorAll('.item').forEach(it => {
    const id = it.dataset.id; const d = items.get(id)?.data;
    if(!d) return;
    const u = SIZE_UNITS[d.size] || 1;
    total += u;
    if(u===5) med++;
    if(u===15) large++;
  });
  return { total, med, large };
}

/* Accept rules:
   - Clothing (.slot): 1 item (except Rings: up to 5)
   - Weapon (.wslot): 1 item; if data-weapon="misc", only Small/Medium
   - Quiver (.qdrop): ammo & items with 'quiver' in name
   - Equipment (.eq-drop): total units ≤ 15; Mediums ≤ 3; Large ≤ 1
     (unless data-eq="camp" which is unlimited)
   - Locked equipment slots (Slots 1–4) reject drops
*/
function canAccept(zone, data){
  if(!data) return false;

  if(zone.classList.contains('slot')){
    const isRings = zone.dataset.slot === 'rings';
    if(isRings) return zone.querySelectorAll('.item').length < 5;
    return zone.querySelectorAll('.item').length === 0;
  }
  if(zone.classList.contains('wslot')){
    if(zone.children.length > 0) return false;
    if(zone.dataset.weapon === 'misc' && data.size === 'Large') return false;
    return true;
  }
  if(zone.classList.contains('qdrop')){
    if(/quiver/i.test(data.nameLower)) return true;
    return data.isAmmo === true;
  }
  if(zone.classList.contains('eq-drop')){
    if(zone.dataset.eq === 'camp') return true; // unlimited
    if(zone.classList.contains('locked')) return false;
    const u = SIZE_UNITS[data.size] || 1;
    const { total, med, large } = currentUnits(zone);
    if(total + u > 15) return false;
    if(u===15 && (large >= 1 || total>0)) return (total===0 && large===0);
    if(u===5  && med >= 3) return false;
    return true;
  }
  return false;
}

/* Optional highlight during drag */
function markDrops(id, on){
  document.querySelectorAll('.eq-drop, .slot, .wslot, .qdrop').forEach(zone => {
    zone.classList.remove('valid','invalid');
    if(!on) return;
    const ok = canAccept(zone, id ? items.get(id)?.data : null);
    zone.classList.add(ok ? 'valid' : 'invalid');
  });
}

/* Ammo merge (stacks of 20) in quiver or equipment zones */
function tryMergeInZone(zone, id){
  if(!zone) return;
  const obj = items.get(id); if(!obj) return;
  const data = obj.data;

  if(!(zone.classList.contains('qdrop') || zone.classList.contains('eq-drop'))) { updateCap(zone); return; }
  if(!data.isAmmo){ updateCap(zone); return; }

  const stacks = Array.from(zone.querySelectorAll('.item'))
    .map(el => items.get(el.dataset.id))
    .filter(o => o && o.data.isAmmo && o.data.nameLower === data.nameLower && o.el !== obj.el);

  let remaining = data.count;
  for(const s of stacks){
    if(remaining <= 0) break;
    if(s.data.count >= 20) continue;
    const space = 20 - s.data.count;
    const add = Math.min(space, remaining);
    s.data.count += add;
    remaining -= add;
    updateItemEl(s.el, s.data);
  }

  if(remaining === 0){
    obj.el.remove(); items.delete(id);
  } else if(remaining !== data.count){
    obj.data.count = remaining;
    updateItemEl(obj.el, obj.data);
  }

  updateCap(zone);
  updateQuiverCounter();
}

/* Quiver counter & +/− buttons (adjust real stacks) */
document.getElementById("ammoPlus").addEventListener("click", () => adjustQuiver(+1));
document.getElementById("ammoMinus").addEventListener("click", () => adjustQuiver(-1));

function getQuiverStacks(){
  const drop = document.getElementById("quiverDrop");
  return Array.from(drop.querySelectorAll(".item"))
    .map(el => items.get(el.dataset.id))
    .filter(o => o && o.data.isAmmo);
}
function adjustQuiver(delta){
  const stacks = getQuiverStacks();
  if(stacks.length === 0) return; // no ammo to adjust

  if(delta > 0){
    for(const s of stacks){
      if(s.data.count < 20){ s.data.count += 1; updateItemEl(s.el, s.data); updateQuiverCounter(); return; }
    }
    // new stack of the first type
    const first = stacks[0];
    const id = 'it' + (idCounter++);
    const el = document.createElement('span');
    el.className = 'item'; el.dataset.id = id;
    const data = { ...first.data, count: 1 };
    updateItemEl(el, data); wireItem(el);
    document.getElementById('quiverDrop').appendChild(el);
    items.set(id, { el, data });
    updateQuiverCounter();
  } else {
    for(let i=stacks.length-1; i>=0; i--){
      const s = stacks[i];
      if(s.data.count > 0){
        s.data.count -= 1;
        if(s.data.count === 0){ s.el.remove(); items.delete(s.el.dataset.id); }
        else updateItemEl(s.el, s.data);
        updateQuiverCounter();
        return;
      }
    }
  }
}
function updateQuiverCounter(){
  const drop = document.getElementById('quiverDrop');
  const out  = document.getElementById('quiverCount');
  let total = 0;
  drop.querySelectorAll('.item').forEach(it => {
    const d = items.get(it.dataset.id)?.data;
    if(d && d.isAmmo) total += (d.count || 1);
  });
  out.textContent = total;
}

/* Capacity bars (equipment only) */
function updateCap(zone){
  if(!zone || !zone.classList.contains('eq-drop')) return;
  if(zone.dataset.eq === 'camp') return; // unlimited
  const { total } = currentUnits(zone);
  const pct = Math.min(100, Math.round((total / 15) * 100));
  const fill = zone.querySelector('.capfill');
  if(fill) fill.style.width = pct + '%';
}
function updateAllCaps(){ document.querySelectorAll('.eq-drop').forEach(updateCap); }
updateAllCaps();

/* Default target for new items */
function findFirstDropTarget(data){
  const eqZones = Array.from(document.querySelectorAll('.eq-drop'));
  for(const z of eqZones){ if(canAccept(z, data || {size:'Small', isAmmo:false, nameLower:''})) return z; }
  const empties = Array.from(document.querySelectorAll('.slot, .wslot')).filter(s => {
    if(s.classList.contains('slot') && s.dataset.slot === 'rings') return s.children.length < 5;
    return s.children.length === 0;
  });
  if(empties[0]) return empties[0];
  return document.getElementById('quiverDrop');
}

/* Slot locks: Slots 1–4 with persistent state */
function saveLockState() {
  const lockStates = {};
  document.querySelectorAll('.eq-drop[data-eq^="slot"]').forEach(zone => {
    lockStates[zone.dataset.eq] = zone.classList.contains('locked');
  });
  localStorage.setItem('dnd_lock_states', JSON.stringify(lockStates));
}

function loadLockState() {
  try {
    const saved = localStorage.getItem('dnd_lock_states');
    if(saved) {
      const lockStates = JSON.parse(saved);
      Object.entries(lockStates).forEach(([slotKey, isLocked]) => {
        const zone = document.querySelector(`.eq-drop[data-eq="${slotKey}"]`);
        const btn = document.querySelector(`button[data-lock-for="${slotKey}"]`);
        if(zone && btn) {
          if(isLocked) {
            zone.classList.add('locked');
            btn.textContent = '🔒';
          } else {
            zone.classList.remove('locked');
            btn.textContent = '🔓';
          }
        }
      });
    }
  } catch(e) {
    console.log('Could not load lock states');
  }
}

document.querySelectorAll('.lock').forEach(btn => {
  btn.addEventListener('click', () => {
    const key = btn.dataset.lockFor;
    const zone = document.querySelector(`.eq-drop[data-eq="${key}"]`);
    if(!zone) return;
    zone.classList.toggle('locked');
    btn.textContent = zone.classList.contains('locked') ? '🔒' : '🔓';
    saveLockState();
  });
});

// Load saved lock states on page load
loadLockState();

// Simple Rations Management
const rationsDialog = document.getElementById('rationsDialog');
const rationsMainMenu = document.getElementById('rationsMainMenu');
const addRationMenu = document.getElementById('addRationMenu');

document.getElementById('rationsIndicator').addEventListener('click', () => {
  rationsMainMenu.style.display = 'block';
  addRationMenu.style.display = 'none';
  rationsDialog.showModal();
});

document.getElementById('eatRationsBtn').addEventListener('click', () => {
  if (rationsDays >= 1.0) {
    rationsDays = Math.max(0, rationsDays - 1.0);
    updateRationsDisplay();
    if (rationsDays === 0) {
      alert('You are out of rations!');
    }
  } else {
    alert('Not enough rations to eat for a full day!');
  }
});

document.getElementById('addRationsBtn').addEventListener('click', () => {
  rationsMainMenu.style.display = 'none';
  addRationMenu.style.display = 'block';
  document.getElementById('rationName').value = '';
});

document.getElementById('cancelRationsBtn').addEventListener('click', () => {
  rationsDialog.close();
});

document.getElementById('cancelAddRationBtn').addEventListener('click', () => {
  rationsMainMenu.style.display = 'block';
  addRationMenu.style.display = 'none';
});

document.getElementById('confirmAddRationBtn').addEventListener('click', () => {
  const name = document.getElementById('rationName').value.trim();
  const amount = parseFloat(document.getElementById('rationAmount').value);
  
  if (name && amount) {
    if (rationsDays + amount <= 7.0) {
      rationsDays += amount; // Directly add to current rations
      rationsStock.push({name, amount}); // Just for display/tracking
      updateRationsDisplay();
      rationsMainMenu.style.display = 'block';
      addRationMenu.style.display = 'none';
    } else {
      alert(`Not enough space! You have ${rationsDays.toFixed(1)} days. Maximum is 7.0 days total.`);
    }
  } else {
    alert('Please enter a name and select an amount.');
  }
});
/* Water and Rations Management */

let waterLevel = 1.0; // Start with full waterskin
let rationsDays = 0.0; // Start with NO rations
let rationsStock = []; // For display purposes only

// Initialize survival indicators
function updateWaterDisplay() {
  const waterFill = document.getElementById('waterFill');
  const waterIndicator = document.getElementById('waterIndicator');
  const currentWaterSpan = document.getElementById('currentWater');
  
  const percentage = (waterLevel / 1.0) * 100;
  waterFill.style.height = percentage + '%';
  currentWaterSpan.textContent = waterLevel.toFixed(2);
  
  if (waterLevel > 0) {
    waterIndicator.classList.add('has-resources');
  } else {
    waterIndicator.classList.remove('has-resources');
  }
  
  scheduleSave(); // Auto-save water changes
}

function updateRationsDisplay() {
  const rationsFill = document.getElementById('rationsFill');
  const rationsIndicator = document.getElementById('rationsIndicator');
  const currentRationsSpan = document.getElementById('currentRations');
  
  // Show current available rations, not stockpile
  const percentage = (rationsDays / 7.0) * 100;
  rationsFill.style.height = percentage + '%';
  currentRationsSpan.textContent = rationsDays.toFixed(1);
  
  if (rationsDays > 0) {
    rationsIndicator.classList.add('has-resources');
  } else {
    rationsIndicator.classList.remove('has-resources');
  }
  
  scheduleSave(); // Auto-save rations changes
}

// Water Management
const waterDialog = document.getElementById('waterDialog');
const waterMainMenu = document.getElementById('waterMainMenu');
const waterFillMenu = document.getElementById('waterFillMenu');

document.getElementById('waterIndicator').addEventListener('click', () => {
  waterMainMenu.style.display = 'block';
  waterFillMenu.style.display = 'none';
  waterDialog.showModal();
});

document.getElementById('drinkWaterBtn').addEventListener('click', () => {
  if (waterLevel >= 0.25) {
    waterLevel = Math.max(0, waterLevel - 0.25);
    updateWaterDisplay();
    if (waterLevel === 0) {
      alert('Your waterskin is now empty!');
    }
  } else {
    alert('Not enough water to drink!');
  }
});

document.getElementById('fillWaterBtn').addEventListener('click', () => {
  waterMainMenu.style.display = 'none';
  waterFillMenu.style.display = 'block';
  setupWaterDrag();
});

document.getElementById('backToWaterBtn').addEventListener('click', () => {
  waterMainMenu.style.display = 'block';
  waterFillMenu.style.display = 'none';
});

document.getElementById('cancelWaterBtn').addEventListener('click', () => {
  waterDialog.close();
});

document.getElementById('confirmWaterBtn').addEventListener('click', () => {
  updateWaterDisplay();
  waterDialog.close();
});

// Quick action buttons
document.getElementById('quickDrinkBtn').addEventListener('click', () => {
  if (waterLevel >= 0.25) {
    waterLevel = Math.max(0, waterLevel - 0.25);
    updateWaterDisplay();
    if (waterLevel === 0) {
      // Brief visual feedback instead of alert
      const btn = document.getElementById('quickDrinkBtn');
      btn.style.background = '#d32f2f';
      setTimeout(() => btn.style.background = '', 200);
    }
  } else {
    // Visual feedback for insufficient water
    const btn = document.getElementById('quickDrinkBtn');
    btn.style.background = '#d32f2f';
    setTimeout(() => btn.style.background = '', 200);
  }
});

document.getElementById('quickEatBtn').addEventListener('click', () => {
  if (rationsDays >= 0.25) {
    rationsDays = Math.max(0, rationsDays - 0.25);
    updateRationsDisplay();
    if (rationsDays === 0) {
      // Brief visual feedback instead of alert
      const btn = document.getElementById('quickEatBtn');
      btn.style.background = '#d32f2f';
      setTimeout(() => btn.style.background = '', 200);
    }
  } else {
    // Visual feedback for insufficient rations
    const btn = document.getElementById('quickEatBtn');
    btn.style.background = '#d32f2f';
    setTimeout(() => btn.style.background = '', 200);
  }
});

// Water drag functionality
function setupWaterDrag() {
  const waterLevelEl = document.getElementById('waterLevel');
  const dragHandle = document.getElementById('dragHandle');
  const waterskin = document.getElementById('waterskin');
  
// Set initial position
  const initialPercentage = waterLevel * 100;
  waterLevelEl.style.height = initialPercentage + '%';
  // Ensure handle is never hidden - clamp between 5% and 95%
  const handleTop = Math.max(5, Math.min(95, (100 - initialPercentage)));
  dragHandle.style.top = handleTop + '%';
  
  let isDragging = false;
  
  dragHandle.addEventListener('mousedown', startDrag);
  dragHandle.addEventListener('touchstart', startDrag);
  
  function startDrag(e) {
    isDragging = true;
    e.preventDefault();
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', stopDrag);
  }
  
function drag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    const rect = waterskin.getBoundingClientRect();
    const clientY = e.clientY || e.touches[0].clientY;
    const relativeY = clientY - rect.top;
    let percentage = Math.max(0, Math.min(100, ((rect.height - relativeY) / rect.height) * 100));
    
// Snap to nearest quarter (0, 25, 50, 75, 100)
    const quarters = [0, 25, 50, 75, 100];
    const closest = quarters.reduce((prev, curr) => 
      Math.abs(curr - percentage) < Math.abs(prev - percentage) ? curr : prev
    );
    percentage = closest;
    
    waterLevel = percentage / 100;
    waterLevelEl.style.height = percentage + '%';
    // Keep handle visible - clamp between 5% and 95%
    const handleTop = Math.max(5, Math.min(95, (100 - percentage)));
    dragHandle.style.top = handleTop + '%';
    
    // Add water sloshing effect
    waterLevelEl.style.animation = 'none';
    waterLevelEl.offsetHeight; // Trigger reflow
    waterLevelEl.style.animation = 'water-slosh 0.5s ease-out';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', stopDrag);
    document.removeEventListener('touchmove', drag);
    document.removeEventListener('touchend', stopDrag);
  }
}

/* Tap-friendly: avoid long-press context menu during drag */
document.addEventListener('contextmenu', e => { if(dragId) e.preventDefault(); });

/* Swipe gestures for quick actions */
let swipeStartX = 0, swipeStartY = 0;
document.addEventListener('touchstart', e => {
  if(e.touches.length === 1) {
    swipeStartX = e.touches[0].clientX;
    swipeStartY = e.touches[0].clientY;
  }
}, {passive: true});

document.addEventListener('touchend', e => {
  if(e.changedTouches.length === 1) {
    const deltaX = e.changedTouches[0].clientX - swipeStartX;
    const deltaY = e.changedTouches[0].clientY - swipeStartY;
    
    // Swipe right to add item
    if(deltaX > 100 && Math.abs(deltaY) < 50) {
      openAddDialog();
    }
  }
}, {passive: true});

// Initialize storage and load saved data
initStorage();

// Wait a moment for storage to initialize, then load
setTimeout(() => {
  if (!loadAppData()) {
    // If no saved data, use defaults
    updateWaterDisplay();
    updateRationsDisplay();
  }
}, 100);

// Save data when page is about to unload
window.addEventListener('beforeunload', forceSave);

// Save data when app loses focus (mobile apps being backgrounded)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    forceSave();
  }
});;

/* Spellbook Management */
let editingSpellId = null;
let spellIdCounter = 1;
const spells = new Map();

// Show spellbook page
document.getElementById('spellbookIndicator').addEventListener('click', () => {
  document.querySelector('.screen').style.display = 'none';
  document.getElementById('spellbookPage').style.display = 'block';
});


// Back to inventory
document.getElementById('backToInventoryBtn').addEventListener('click', () => {
  document.querySelector('.screen').style.display = 'flex';
  document.getElementById('spellbookPage').style.display = 'none';
});

// Spell dialog management
const spellDialog = document.getElementById('spellDialog');
const spellForm = document.getElementById('spellForm');

document.getElementById('addSpellBtn').addEventListener('click', () => openAddSpellDialog());
document.getElementById('cancelSpellBtn').addEventListener('click', () => spellDialog.close());
document.getElementById('deleteSpellBtn').addEventListener('click', () => {
  if(!editingSpellId) return;
  const spell = spells.get(editingSpellId);
  if(spell) {
    spell.element.remove();
    spells.delete(editingSpellId);
    scheduleSave(); // Auto-save spell deletion
  }
  spellDialog.close();
});


// Auto-fill spell data from D&D APIs
document.getElementById('autoFillBtn').addEventListener('click', async () => {
  const spellName = document.getElementById('spellName').value.trim();
  if (!spellName) {
    alert('Please enter a spell name first');
    return;
  }
  
  // Show loading
  const btn = document.getElementById('autoFillBtn');
  const originalText = btn.textContent;
  btn.textContent = 'Loading...';
  btn.disabled = true;
  
try {
    const spellData = await fetchSpellData(spellName);
    if (spellData) {
      populateSpellForm(spellData);
      alert(`Spell data found and loaded for "${spellData.name}"!`);
    } else {
      alert(`Spell "${spellName}" not found in:\n• D&D 5e API\n• Open5e API\n• Deep Magic Vol 1 & 2\n• Blackstaff's 1000 Spells\n• Tasha's Cauldron\n\nPlease fill in manually.`);
    }
  } catch (error) {
    console.error('Auto-fill error:', error);
    alert(`Error searching for "${spellName}". Check console for details.\nPlease fill in manually.`);
  }
  
  btn.textContent = originalText;
  btn.disabled = false;
});

async function fetchSpellData(spellName) {
  const searchName = spellName.toLowerCase().trim();
  
  // 0. Check common spells database first (instant response)
  const commonSpell = checkCommonSpells(searchName);
  if (commonSpell) {
    return commonSpell;
  }
  
  // 1. Try D&D 5e API
  try {
    const apiName = searchName.replace(/\s+/g, '-');
    const response = await fetch(`https://www.dnd5eapi.co/api/2014/spells/${apiName}`);
    if (response.ok) {
      const data = await response.json();
      return {
        name: data.name,
        level: data.level === 0 ? 'cantrip' : data.level.toString(),
        school: data.school.name,
        castingTime: data.casting_time,
        range: data.range,
        components: data.components.join(', ') + (data.material ? ` (${data.material})` : ''),
        duration: data.duration,
        concentration: data.concentration,
        description: data.desc.join('\n\n')
      };
    }
  } catch (error) {
    console.log('D&D 5e API failed, trying alternatives...');
  }

  // 2. Try Open5e API (more comprehensive)
  try {
    const response = await fetch(`https://api.open5e.com/spells/?search=${encodeURIComponent(searchName)}`);
    if (response.ok) {
      const data = await response.json();
      if (data.results && data.results.length > 0) {
        const spell = data.results[0];
        return {
          name: spell.name,
          level: spell.level_int === 0 ? 'cantrip' : spell.level_int.toString(),
          school: spell.school,
          castingTime: spell.casting_time,
          range: spell.range,
          components: spell.components,
          duration: spell.duration,
          concentration: spell.concentration === 'yes',
          description: spell.desc
        };
      }
    }
  } catch (error) {
    console.log('Open5e API failed, trying PDFs...');
  }

// 3. Search local spell text files
  try {
    const textResult = await searchSpellFiles(searchName);
    if (textResult) {
      return textResult;
    }
  } catch (error) {
    console.log('Text file search failed, trying web scraping...');
  }

  // 4. Try web scraping (limited by CORS, but attempt)
  try {
    const webResult = await searchWebSources(searchName);
    if (webResult) {
      return webResult;
    }
  } catch (error) {
    console.log('Web scraping failed');
  }

  return null;
}
      
async function searchSpellFiles(spellName) {
  const spellFiles = [
    'Books/Spell1.txt',
    'Books/Spell2.txt', 
    'Books/Spell3.txt',
    'Books/Spell4.txt',
    'Books/Spell5.txt'
  ];

  const searchLower = spellName.toLowerCase().trim();
  console.log('Searching for spell:', searchLower);

  for (const filePath of spellFiles) {
    try {
      const response = await fetch(filePath);
      if (response.ok) {
        const textData = await response.text();
        console.log(`Searching in ${filePath}...`);
        
        // Split file into individual spells
        const spells = splitIntoSpells(textData);
        console.log(`Found ${spells.length} spell blocks in ${filePath}`);
        
        // Search through each spell block
        for (const spellBlock of spells) {
          const firstLine = spellBlock.split('\n')[0].trim().toLowerCase();
          console.log('Checking spell:', firstLine);
          
          if (firstLine === searchLower) {
            console.log('MATCH FOUND!');
            const spellData = parseSpellBlock(spellBlock);
            if (spellData) {
              return spellData;
            }
          }
        }
      }
    } catch (error) {
      console.log(`Failed to search ${filePath}:`, error);
    }
  }
  return null;
}

// Split text file into individual spell blocks
function splitIntoSpells(textContent) {
  const spells = [];
  const lines = textContent.split('\n');
  let currentSpell = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Check if this line looks like a spell name (followed by "Casting Time:")
    if (line.length > 0 && i + 1 < lines.length) {
      const nextLine = lines[i + 1].trim();
      if (nextLine.match(/^Casting\s+Time:/i)) {
        // Save previous spell if exists
        if (currentSpell.length > 0) {
          spells.push(currentSpell.join('\n'));
        }
        // Start new spell
        currentSpell = [line];
        continue;
      }
    }
    
    // Add line to current spell
    if (currentSpell.length > 0) {
      currentSpell.push(lines[i]);
    }
  }
  
  // Add last spell
  if (currentSpell.length > 0) {
    spells.push(currentSpell.join('\n'));
  }
  
  return spells;
}

// Parse a single spell block
function parseSpellBlock(spellBlock) {
  const lines = spellBlock.split('\n');
  const spellName = lines[0].trim();

  const castingTimeMatch = spellBlock.match(/Casting\s+Time:\s*([^\n]+)/i);
  const rangeMatch = spellBlock.match(/Range:\s*([^\n]+)/i);
  const componentsMatch = spellBlock.match(/Components:\s*([^\n]+)/i);
  const durationMatch = spellBlock.match(/Duration:\s*([^\n]+)/i);

  // Find where description starts (after Duration line)
  let description = '';
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/^Duration:/i)) {
      description = lines.slice(i + 1).join('\n').trim();
      description = description.replace(/"[^"]*"$/s, '').trim();
      break;
    }
  }

  // Level & school
  let level = '1';
  let school = '';
  const headerText = lines.slice(0, 5).join(' ');
  const levelMatch = headerText.match(/(\d+)(?:st|nd|rd|th)[\s-]level/i);
  if (levelMatch) level = levelMatch[1];
  else if (/cantrip/i.test(headerText)) level = 'cantrip';

  const schoolMatch = headerText.match(/\b(abjuration|conjuration|divination|enchantment|evocation|illusion|necromancy|transmutation)\b/i);
  if (schoolMatch) school = schoolMatch[1];

  const concentration = /concentration/i.test(durationMatch ? durationMatch[1] : '');

  const result = {
    name: spellName,
    level,
    school,
    castingTime: castingTimeMatch ? castingTimeMatch[1].trim() : '1 action',
    range: rangeMatch ? rangeMatch[1].trim() : 'Touch',
    components: componentsMatch ? componentsMatch[1].trim() : 'V, S',
    duration: durationMatch ? durationMatch[1].trim() : 'Instantaneous',
    concentration,
    description
  };

  return result;
}


// No longer needed - we read text files directly

// Fallback database for common spells
const commonSpells = {
  'thorn whip': {
    name: 'Thorn Whip',
    level: 'cantrip',
    school: 'Transmutation',
    castingTime: '1 action',
    range: '30 feet',
    components: 'V, S, M (the stem of a thorny plant)',
    duration: 'Instantaneous',
    concentration: false,
    description: 'You create a long, vine-like whip covered in thorns that lashes out at your command toward a creature in range. Make a melee spell attack against the target. If the attack hits, the creature takes 1d6 piercing damage, and if the creature is Large or smaller, you pull the creature up to 10 feet closer to you. This spell\'s damage increases by 1d6 when you reach 5th level (2d6), 11th level (3d6), and 17th level (4d6).'
  },
'fireball': {
  name: 'Fireball',
  level: '3',
  school: 'Evocation',
  castingTime: '1 action',
  range: '150 feet',
  components: 'V, S, M (a tiny ball of bat guano and sulfur)',
  duration: 'Instantaneous',
  concentration: false,
  description: 'A bright streak flashes from your pointing finger to a point you choose within range and then blossoms with a low roar into an explosion of flame. Make a ranged spell attack against the target. On a hit, the target takes 1d10 force damage. The spell creates more than one beam when you reach higher levels: two beams at 5th level, three beams at 11th level, and four beams at 17th level.'
},

  'magic missile': {
    name: 'Magic Missile',
    level: '1',
    school: 'Evocation',
    castingTime: '1 action',
    range: '120 feet',
    components: 'V, S',
    duration: 'Instantaneous',
    concentration: false,
    description: 'You create three glowing darts of magical force. Each dart hits a creature of your choice that you can see within range. A dart deals 1d4 + 1 force damage to its target. The darts all strike simultaneously, and you can direct them to hit one creature or several.'
  },
  'cure wounds': {
    name: 'Cure Wounds',
    level: '1',
    school: 'Evocation',
    castingTime: '1 action',
    range: 'Touch',
    components: 'V, S',
    duration: 'Instantaneous',
    concentration: false,
    description: 'A creature you touch regains a number of hit points equal to 1d8 + your spellcasting ability modifier. This spell has no effect on undead or constructs.'
  },
  'eldritch blast': {
    name: 'Eldritch Blast',
    level: 'cantrip',
    school: 'Evocation',
    castingTime: '1 action',
    range: '120 feet',
    components: 'V, S',
    duration: 'Instantaneous',
    concentration: false,
    description: 'A beam of crackling energy streaks toward a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 force damage. The spell creates more than one beam when you reach higher levels: two beams at 5th level, three beams at 11th level, and four beams at 17th level.'
  }
};

function checkCommonSpells(spellName) {
  const key = spellName.toLowerCase().trim();
  return commonSpells[key] || null;
}

function parseSpellFromText(textContent, spellName) {
  // Create flexible regex that matches spell name at start of line or after newlines
  const spellNameEscaped = spellName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/\s+/g, '\\s+');
  const spellNameRegex = new RegExp(`(?:^|\\n)\\s*(${spellNameEscaped})\\s*(?:\\n|$)`, 'im');
  const spellMatch = textContent.match(spellNameRegex);
  
  if (!spellMatch) return null;

  const startIndex = spellMatch.index + spellMatch[0].indexOf(spellMatch[1]);
  
  // Find the end - either next spell name (capital letter at start of line) or end of file
  const afterSpell = textContent.substring(startIndex + spellMatch[1].length);
  const nextSpellMatch = afterSpell.match(/\n\s*[A-Z][A-Za-z\s']{2,}\s*\n\s*Casting Time:/);
  const endIndex = nextSpellMatch ? startIndex + spellMatch[1].length + nextSpellMatch.index : textContent.length;
  
  const spellBlock = textContent.substring(startIndex, endIndex);
  console.log('Parsing spell block:', spellBlock.substring(0, 200));
  
  // More flexible extraction patterns
  const castingTimeMatch = spellBlock.match(/Casting\s+Time:\s*([^\n]+)/i);
  const rangeMatch = spellBlock.match(/Range:\s*([^\n]+)/i);
  const componentsMatch = spellBlock.match(/Components:\s*([^\n]+)/i);
  const durationMatch = spellBlock.match(/Duration:\s*([^\n]+)/i);
  
  // Determine level and school from context
  let level = '1';
  let school = '';
  
  // Check for level/school line (common formats)
  const levelSchoolMatch = spellBlock.match(/(\d+)(?:st|nd|rd|th)[\s-]level\s+(\w+)/i);
  if (levelSchoolMatch) {
    level = levelSchoolMatch[1];
    school = levelSchoolMatch[2];
  } else if (/cantrip/i.test(spellBlock.substring(0, 200))) {
    level = 'cantrip';
  }
  
  // Try to find school if not found
  if (!school) {
    const schoolMatch = spellBlock.match(/\b(abjuration|conjuration|divination|enchantment|evocation|illusion|necromancy|transmutation)\b/i);
    if (schoolMatch) school = schoolMatch[1];
  }
  
  // Check for concentration
  const concentration = /concentration/i.test(durationMatch ? durationMatch[1] : '');
  
  // Extract description - everything after Duration line
  let description = '';
  const durationIndex = spellBlock.search(/Duration:\s*[^\n]+/i);
  if (durationIndex > -1) {
    const afterDuration = spellBlock.substring(durationIndex);
    const descStart = afterDuration.indexOf('\n');
    if (descStart > -1) {
      description = afterDuration.substring(descStart + 1).trim();
      // Remove quoted flavor text at the end
      description = description.replace(/"[^"]*"$/s, '').trim();
    }
  }

  const result = {
    name: spellMatch[1].trim(),
    level: level,
    school: school,
    castingTime: castingTimeMatch ? castingTimeMatch[1].trim() : '1 action',
    range: rangeMatch ? rangeMatch[1].trim() : 'Touch',
    components: componentsMatch ? componentsMatch[1].trim() : 'V, S',
    duration: durationMatch ? durationMatch[1].trim() : 'Instantaneous',
    concentration: concentration,
    description: description
  };
  
  console.log('Parsed spell:', result);
  return result;
}


async function searchWebSources(spellName) {
  // Web scraping is limited by CORS policies
  // This is a placeholder for potential future implementation
  // You could potentially use a proxy service or browser extension
  
  console.log(`Searching web sources for ${spellName} - limited by CORS`);
  return null;
}

function populateSpellForm(spellData) {
  document.getElementById('spellLevel').value = spellData.level;
  document.getElementById('spellSchool').value = spellData.school;
  document.getElementById('castingTime').value = spellData.castingTime;
  document.getElementById('spellRange').value = spellData.range;
  document.getElementById('spellComponents').value = spellData.components;
  document.getElementById('spellDuration').value = spellData.duration;
  document.getElementById('spellConcentration').checked = spellData.concentration;
  document.getElementById('spellDescription').value = spellData.description;
}

function openAddSpellDialog() {
  editingSpellId = null;
  document.getElementById('spellDlgTitle').textContent = 'Add Spell';
  document.getElementById('deleteSpellBtn').style.display = 'none';
  spellForm.reset();
  spellDialog.showModal();
}

function openEditSpellDialog(id) {
  const spell = spells.get(id);
  if (!spell) return;
  
  editingSpellId = id;
  document.getElementById('spellDlgTitle').textContent = 'Edit Spell';
  document.getElementById('deleteSpellBtn').style.display = 'inline-block';
  
  // Populate form with spell data
  document.getElementById('spellName').value = spell.data.name;
  document.getElementById('spellLevel').value = spell.data.level;
  document.getElementById('spellSchool').value = spell.data.school || '';
  document.getElementById('castingTime').value = spell.data.castingTime || '';
  document.getElementById('spellRange').value = spell.data.range || '';
  document.getElementById('spellComponents').value = spell.data.components || '';
  document.getElementById('spellDuration').value = spell.data.duration || '';
  document.getElementById('spellConcentration').checked = spell.data.concentration || false;
  document.getElementById('spellDescription').value = spell.data.description || '';
  
  spellDialog.showModal();
}

// Save spell
spellForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const name = document.getElementById('spellName').value.trim();
  if (!name) return;
  
  const spellData = {
    name,
    level: document.getElementById('spellLevel').value,
    school: document.getElementById('spellSchool').value,
    castingTime: document.getElementById('castingTime').value,
    range: document.getElementById('spellRange').value,
    components: document.getElementById('spellComponents').value,
    duration: document.getElementById('spellDuration').value,
    concentration: document.getElementById('spellConcentration').checked,
    description: document.getElementById('spellDescription').value
  };
  
if (editingSpellId) {
    // Update existing spell
    const spell = spells.get(editingSpellId);
    if (spell) {
      spell.data = spellData;
      updateSpellElement(spell.element, spellData);
    }
  } else {
    // Create new spell
    const id = 'spell' + (spellIdCounter++);
    const element = createSpellElement(spellData, id);
    const listId = spellData.level === 'cantrip' ? 'cantrips' : `level${spellData.level}`;
    document.getElementById(listId).appendChild(element);
    spells.set(id, { data: spellData, element });
  }
  
  scheduleSave(); // Auto-save spell changes
  spellDialog.close();
});

function createSpellElement(spellData, id) {
// Prevent the "Show text" button from bubbling to the row's edit click
element.addEventListener('click', function(ev) {
  var t = ev.target;
  if (t && t.closest && t.closest('.spell-show-btn')) {
    ev.stopPropagation();
  }
}, true);



  const element = document.createElement('div');
  element.className = 'spell-item';
  element.dataset.id = id;
  element.addEventListener('click', () => openEditSpellDialog(id));
  
  updateSpellElement(element, spellData);
  return element;
}

function updateSpellElement(element, spellData) {
  var indicators = getSpellIndicators(spellData);
  var school = (spellData.school || '').trim();
  var levelLabel = spellData.level === 'cantrip' ? 'Cantrip' : (spellData.level + ' lvl');
  var subtitle = school ? (school + ' • ' + levelLabel) : levelLabel;
  var description = (spellData.description || '').trim();

  // store full text for the modal
  element.dataset.description = description;
  element.dataset.spellName = spellData.name;

  element.innerHTML = ''
    + '<div>'
    +   '<div class="spell-name">' + spellData.name + '</div>'
    +   '<div class="spell-school">' + subtitle + '</div>'
    + '</div>'
    + '<button type="button" class="spell-show-btn">Show text</button>'
    + '<div class="spell-indicators">' + indicators + '</div>';
}



function getSpellIndicators(spellData) {
  let indicators = '';
  
  // Determine action type from casting time
  const castingTime = (spellData.castingTime || '').toLowerCase();
  if (castingTime.includes('bonus')) {
    indicators += '<div class="spell-indicator bonus">B</div>';
  } else if (castingTime.includes('reaction')) {
    indicators += '<div class="spell-indicator reaction">R</div>';
  } else {
    indicators += '<div class="spell-indicator action">A</div>';
  }
  
  // Concentration
  if (spellData.concentration) {
    indicators += '<div class="spell-indicator concentration">C</div>';
  }
  
  return indicators;
}


if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js')
    .then(reg => console.log('SW registered'))
    .catch(err => console.log('SW failed:', err));
}

</script>
</body>
</html>
